import { prefix } from "../constants.js";
import type { FontData } from "../fontMetaDataSchema.js";
import fs from "fs/promises";
import formatDate from "../formatDate.js";

const generateFile = "packages/viteFontPlugin/src/types/pluginConfigType.ts";

export default async function generatePluginConfigType(fontData: FontData) {
  const generatedFontConfigType = pluginConfigType(fontData);

  try {
    await fs.writeFile(generateFile, generatedFontConfigType);
  } catch (err) {
    throw new Error(`${prefix} Error creating '${generateFile}': ${err}`);
  }
}

function pluginConfigType(fontData: FontData) {
  const { fontConfigType, fontTitlesType } = generateFontTypes(fontData);
  return `// Generated by scripts/processGoogleFonts.ts: ${formatDate(
    new Date()
  )}

export type FontPluginConfig = {
  config?: {
    suppressNotOpenSourceWarnings?: boolean,
    handleCss?: "inlineHead" | "buildFile",
    selfHost?: boolean,
    defaultPreload?: boolean,
    defaultModifiedFallback?: boolean,
    defaultDisplay?: "auto" | "block" | "swap" | "fallback" | "optional",
    includeItalicsByDefault?: boolean,
  },
  fonts: Array<${fontConfigType} ${fontTitlesType}>
}
`;
}

function generateFontTypes(fontData: FontData) {
  let fontConfigType = "";
  let fontTitlesType = "";

  fontData.forEach(({ family, subsets, weights, axes }) => {
    const { roman, italic } = weights;
    fontTitlesType += `| "${family}"\n`;

    fontConfigType += `
    | {
        font: "${family}",
        className?: string,
        cssVariable?: string,
        preload?: boolean,
        modifiedFallback?: boolean,
        customFallback?: string,
        display?: "auto" | "block" | "swap" | "fallback" | "optional",${generateWeights(
          roman,
          axes
        )}${generateItalics(italic)}${generateField(
      subsets,
      "subsets"
    )}${generateField(axes, "axes")}
    }`;
  });

  return {
    fontConfigType,
    fontTitlesType,
  };
}

function generateWeights(roman: number[], axes: string[]) {
  if (roman.length === 0) {
    return `${axes.length > 0 ? '\n\t\t\t\tweight?: "variable,"' : ""}`;
  }

  return `\n\t\t\t\tweight?: "all"${
    axes.length > 0 ? ' | "variable"' : ""
  } | ${roman.join(" | ")} | Array<${roman.join(" | ")}>${
    roman.length > 1
      ? ` | { min: ${roman.slice(0, -1).join(" | ")}, max: ${roman
          .slice(1)
          .join(" | ")} }`
      : ""
  }`;
}

function generateItalics(italics: number[]) {
  if (italics.length === 0) {
    return ``;
  }

  return `\n\t\t\t\titalic?: "all" | boolean | ${italics.join(
    " | "
  )} | Array<${italics.join(" | ")}>${
    italics.length > 1
      ? ` | { min: ${italics.slice(0, -1).join(" | ")}, max: ${italics
          .slice(1)
          .join(" | ")} }`
      : ""
  },`;
}

function generateField(field: string[], fieldName: string): string {
  if (field.length === 0) {
    return "";
  }

  return `\n\t\t\t\t${fieldName}?: "all" | ${field
    .map((f) => `"${f}"`)
    .join(" | ")} | Array<${field.map((f) => `"${f}"`).join(" | ")}>,`;
}
