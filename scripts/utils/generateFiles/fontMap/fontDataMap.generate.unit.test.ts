import generateFontDataMap from "./fontDataMap.generate.js";
import fs from "fs/promises";
import { join } from "path";
import formatDate from "../../formatDate.js";
import type { FontData } from "../../fontMetaData/fontMetaData.schema.js";

vi.mock("fs/promises");
vi.mock("../../formatDate");
vi.mock("../../../processGoogleFonts.js", () => ({
  scriptPrefix: "[Mocked Script Prefix]",
}));

describe("generateFontDataMap", () => {
  const mockFontData: FontData = [
    {
      family: "Roboto",
      subsets: ["latin", "cyrillic"],
      axes: ["wght", "ital"],
      weights: { italic: [100], roman: [400] },
    },
    {
      family: "Open Sans",
      subsets: ["latin"],
      axes: [],
      weights: { italic: [200], roman: [300] },
    },
  ];

  const mockDate = "2024-01-21";
  const mockFolderPaths = ["path1", "path2"];

  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(formatDate).mockReturnValue(mockDate);
    vi.mocked(fs.writeFile).mockResolvedValue(undefined);
  });

  it("should generate TypeScript file with correct font data map", async () => {
    await generateFontDataMap(mockFontData, mockFolderPaths);

    const expectedContent = `// Generated by scripts/processGoogleFonts: ${mockDate}

export type FontData = {
  subsets: string[];
  weights: {
    roman: number[];
    italic: number[];
  };
  axes: string[];
};

export type FontDataMap = Map<string, FontData>;

export const fontData: FontDataMap = new Map([
  ["Roboto", {
  "subsets": [
    "latin",
    "cyrillic"
  ],
  "axes": [
    "wght",
    "ital"
  ],
  "weights": {
    "italic": [
      100
    ],
    "roman": [
      400
    ]
  }
}],
  ["Open Sans", {
  "subsets": [
    "latin"
  ],
  "axes": [],
  "weights": {
    "italic": [
      200
    ],
    "roman": [
      300
    ]
  }
}]
]);
`;

    // Verify writeFile was called with correct arguments for each path
    mockFolderPaths.forEach((path) => {
      expect(fs.writeFile).toHaveBeenCalledWith(
        join(path, "googleFontDataMap.ts"),
        expectedContent
      );
    });

    expect(fs.writeFile).toHaveBeenCalledTimes(mockFolderPaths.length);
  });

  it("should handle empty folder paths array", async () => {
    await generateFontDataMap(mockFontData, []);
    expect(fs.writeFile).not.toHaveBeenCalled();
  });

  it("should throw error when file writing fails", async () => {
    const mockError = new Error("Write failed");
    vi.mocked(fs.writeFile).mockRejectedValue(mockError);

    await expect(
      generateFontDataMap(mockFontData, mockFolderPaths)
    ).rejects.toThrow(/Error creating 'googleFontDataMap.ts'/);
  });

  it("should handle multiple folder paths correctly", async () => {
    const multiplePaths = ["path1", "path2", "path3"];
    await generateFontDataMap(mockFontData, multiplePaths);

    expect(fs.writeFile).toHaveBeenCalledTimes(multiplePaths.length);
    multiplePaths.forEach((path) => {
      expect(fs.writeFile).toHaveBeenCalledWith(
        join(path, "googleFontDataMap.ts"),
        expect.any(String)
      );
    });
  });
});
