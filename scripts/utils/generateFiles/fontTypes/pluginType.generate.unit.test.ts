import generatePluginTypes from "./pluginType.generate.js";
import fs from "fs/promises";
import { join } from "path";
import formatDate from "../../formatDate.js";
import type { FontData } from "../../fontMetaData/fontMetaData.schema.js";
import generateSettingsType from "./settingsType.generate.js";
import generateGoogleFontTypes from "./googleFontTypes.generate.js";
import {
  DISPLAY_OPTIONS,
  SUBSETS_OPTIONS,
} from "../../../../shared/constants.js";

vi.mock("fs/promises");
vi.mock("../../formatDate");
vi.mock("./settingsType.generate.js");
vi.mock("./googleFontTypes.generate.js");
vi.mock("../../../processGoogleFonts.js", () => ({
  scriptPrefix: "[Mocked Script Prefix]",
}));

describe("generatePluginTypes", () => {
  const mockFontData: FontData = [
    {
      family: "Roboto",
      subsets: ["latin"],
      axes: ["wght"],
      weights: { italic: [400], roman: [400] },
    },
  ];

  const mockDate = "2024-01-21";
  const mockFolderPaths = ["path1", "path2"];
  const mockSettingsType = "type SettingsType = { foo: string };";
  const mockGoogleFontTypes = "type GoogleFontTypes = { bar: number };";

  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(formatDate).mockReturnValue(mockDate);
    vi.mocked(fs.writeFile).mockResolvedValue(undefined);
    vi.mocked(generateSettingsType).mockReturnValue(mockSettingsType);
    vi.mocked(generateGoogleFontTypes).mockReturnValue(mockGoogleFontTypes);
  });

  it("should generate TypeScript file", async () => {
    await generatePluginTypes(mockFontData, mockFolderPaths);

    const expectedContent = `// Generated by scripts/processGoogleFonts: ${mockDate}

export type PluginConfig = {
  settings?: PluginConfigSettings,
  googleFonts: GoogleFonts
};

export type DisplayOptions = "${DISPLAY_OPTIONS.join('" | "')}";

export type SubsetOptions = "${SUBSETS_OPTIONS.join('" | "')}";
${mockSettingsType}
${mockGoogleFontTypes}
`;

    mockFolderPaths.forEach((path) => {
      expect(fs.writeFile).toHaveBeenCalledWith(
        join(path, "pluginConfigType.ts"),
        expectedContent
      );
    });

    expect(fs.writeFile).toHaveBeenCalledTimes(mockFolderPaths.length);
    expect(generateSettingsType).toHaveBeenCalled();
    expect(generateGoogleFontTypes).toHaveBeenCalledWith(mockFontData);
  });

  it("should handle empty folder paths array", async () => {
    await generatePluginTypes(mockFontData, []);
    expect(fs.writeFile).not.toHaveBeenCalled();
  });

  it("should throw error when file writing fails", async () => {
    const mockError = new Error("Write failed");
    vi.mocked(fs.writeFile).mockRejectedValue(mockError);

    await expect(
      generatePluginTypes(mockFontData, mockFolderPaths)
    ).rejects.toThrow(/Error creating 'pluginConfigType.ts'/);
  });

  it("should handle multiple folder paths correctly", async () => {
    const multiplePaths = ["path1", "path2", "path3"];
    await generatePluginTypes(mockFontData, multiplePaths);

    expect(fs.writeFile).toHaveBeenCalledTimes(multiplePaths.length);
    multiplePaths.forEach((path) => {
      expect(fs.writeFile).toHaveBeenCalledWith(
        join(path, "pluginConfigType.ts"),
        expect.any(String)
      );
    });
  });
});
